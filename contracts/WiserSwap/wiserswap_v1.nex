pragma nexscript >= 0.2.0;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * Copyright (c) 2023 Ava's DAO
 * Released under the MIT License.
 *
 * WiserSwap
 *
 * A "wise" contract implemenation of a Constant Product Market Maker (CPMM)
 * for Nexa, using a micro pools approach.
 *
 * Individual liquidity provider(s) may deploy their own CPMM contract(s) for
 * managing their own micro pool(s). This design leverages Nexa's UTXO model
 * and its 100K+ TPS throughput, allowing for unparalled scalability and
 * efficiency as compared to ANY other modern-day DEX.
 *
 * GENERAL NOTES
 * --------------------
 * Based on the (CPMM) Cauldron contract by Dagur Valberg Johannsson
 * (source: https://www.cauldron.quest/_files/ugd/ae85be_b1dc04d2b6b94ab5a200e3d8cd197aa3.pdf)
 *
 * Constant Product Property
 * ----------------------------------------
 * WiserSwap adheres to the constant product formula:
 *   K = x * y
 * where K is the constant value, and x and y represent the quantities of
 * <Tokens> and <NEXA>, respectively.
 *
 * Aggregating Micro Pools
 * ----------------------------------------
 * WiserSwap supports aggregation of micro pools to increase liquidity for
 * trades. Multiple pools can be included in a single Transaction to increase
 * asset liquidity and swap efficiency.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * Version     : 01
 * Script Hash : 0x8243901326E0653084DAAC6DE6E05B8929A8DC99
 * Namespace   : WISER01
 *
 * provider       : (bytes20) Pool owner (aka the Provider) (data) public key hash.
 * providerRate   : (int)     Rate charged by the Provider. (measured in <basis points> (bp), eg. 5.25% = 525bp)
 * admin          : (bytes20) A 3rd-party Administrator (specified by the Provider) (data) public key hash; will host & manage the micro pool.
 * adminFee       : (int)     Fee charged by the Administrator. (measured in <basis points> (bp), eg. 5.25% = 525bp)
 * coinCeiling    : (int)     An optional COINS trade boundry (specified by the Provider); also used to enforce an asset's Foundation (set by its Creator). (measured in <satoshis> per <asset>)
 * coinFloor      : (int)     An optional COINS trade boundry (specified by the Provider); also used to enforce an asset's Foundation (set by its Creator). (measured in <satoshis> per <asset>)
 * tokenCeiling   : (int)     An optional TOKENS trade boundry (specified by the Provider); also used to enforce an asset's Foundation (set by its Creator). (measured in <asset> per <satoshis>)
 * tokenFloor     : (int)     An optional TOKENS trade boundry (specified by the Provider); also used to enforce an asset's Foundation (set by its Creator). (measured in <asset> per <satoshis>)
 *
 * For more information, please visit the following resources:
 *   - https://docs.nexa.exchange/wiserswap
 *   - https://avasdao.org
 *
 */
contract WiserSwap(
    bytes20 visible provider,
    int visible providerRate,
    bytes20 visible admin,
    int visible adminFee,
    int visible coinCeiling,
    int visible coinFloor,
    // int visible tokenCeiling,
    // int visible tokenFloor,
) {
    /**
     * Swap (Pool Assets)
     *
     * Allows two (2) assets to be swapped with each other, while maintaining
     * the same (constant) product within the pool.
     */
    function swap() {
        //----------------------------------------------------------------------
        // BEGIN LOCKING BYTECODE VERIFICATION (WORKAROUND) FOR GROUPS
        //----------------------------------------------------------------------

        /* Set Wiser index. */
        int wiserIdx = this.activeInputIndex;

        /* Parse output (script) prefix, plus 1st holder. */
        bytes oPrefix, bytes oHolder = tx.outputs[wiserIdx]
            .lockingBytecode
            .split(33);

        /* Parse output `tokenAmount` size, plus 2nd holder. */
        bytes1 oSize, bytes oHolderToo = oHolder.split(1);

        /* Parse output (script) suffix. */
        // NOTE: Drop the `tokenAmount` value.
        bytes oSuffix = oHolderToo.split(int(oSize))[1];

        /* Parse input (script) prefix, plus 1st holder. */
        bytes iPrefix, bytes iHolder = tx.inputs[wiserIdx]
            .lockingBytecode
            .split(33);

        /* Parse input `tokenAmount` size, plus 2nd holder. */
        bytes1 iSize, bytes iHolderToo = iHolder.split(1);

        /* Parse input (script) suffix. */
        // NOTE: Drop the `tokenAmount` value.
        bytes iSuffix = iHolderToo.split(int(iSize))[1];

        /* Validate input/output prefix scripts. */
        require(oPrefix == iPrefix);

        /* Validate input/output suffix scripts. */
        require(oSuffix == iSuffix);

        //----------------------------------------------------------------------
        // END LOCKING BYTECODE VERIFICATION (WORKAROUND) FOR GROUPS
        //----------------------------------------------------------------------

        //----------------------------------------------------------------------
        // BEGIN CONSTANT PRODUCT VERIFICATION
        //----------------------------------------------------------------------

        /* Set Wiser (satoshis) input value. */
        int wiserValueIn = tx.inputs[wiserIdx].value;

        /* Set Wiser (token) input amount. */
        int wiserAmountIn = tx.inputs[wiserIdx].tokenAmount;

        /* Calculate Wiser (K) input constant. */
        int wiserConstantIn = wiserValueIn * wiserAmountIn;

        /* Set Wiser (satoshis) output value. */
        int wiserValueOut = tx.outputs[wiserIdx].value;

        /* Set basis points (scaling factor). */
        int BASIS_POINTS = 10000;

        /* Set Wiser (satoshis) output value (as basis points). */
        int wiserValueOutBP = wiserValueOut * BASIS_POINTS;

        /* Set Wiser (token) output amount. */
        int wiserAmountOut = tx.outputs[wiserIdx].tokenAmount;

        /* Set Wiser (token) output amount (as basis points). */
        int wiserAmountOutBP = wiserAmountOut * BASIS_POINTS;

        /* Calculate Wiser (K) output constant. */
        int wiserConstantOut = wiserValueOut * wiserAmountOut;

        /* Validate a (minimum) constant product (K) is maintained. */
        // NOTE: A greater constant product is permitted .. as a BONUS!
        require(wiserConstantOut >= wiserConstantIn);

        //----------------------------------------------------------------------
        // END CONSTANT PRODUCT VERIFICATION
        //----------------------------------------------------------------------

        /**
         * Validate (additional) inputs & outputs, beyond the included
         * WiserSwap contract input(s).
         *
         * Additional output indexes:
         *   #1 (requried) Administration fee (in $NEXA) [min: 546 sats]
         *   #2 (requried) Provider auto-pay fee (in $NEXA) [min: 546 sats]
         *   #3 (required) Trader change (in $NEXA) -OR- null data (placeholder)
         */
        require(tx.outputs.length == tx.inputs.length + 3);

        /* Set dust value. */
        int DUST_VALUE = 546;

        /*Set Admin bytecode. */
        // NOTE: Supports ONLY $NEXA assets.
        bytes23 adminBytecode = new LockingBytecodeP2PKT(admin);

        /* Calculate Admin commission. */
        int adminCommission = (wiserValueOut * adminFee) / BASIS_POINTS;

        /* Validate Admin commission (dust) value. */
        // NOTE: Used to discourage denial-of-service (DoS) attacks.
        adminCommission = max(adminCommission, DUST_VALUE);

        /* Set Admin output index. */
        // NOTE: MUST be 3rd from last output.
        int adminOutputIdx = tx.outputs.length - 3;

        /* Verify Admin (commission) bytecode. */
        require(tx.outputs[adminOutputIdx].lockingBytecode == adminBytecode);

        /* Verify Admin (commission) amount. */
        require(tx.outputs[adminOutputIdx].value >= adminCommission);

        /* Set Provider (payout) bytecode. */
        // NOTE: Supports ONLY $NEXA assets.
        bytes23 providerBytecode = new LockingBytecodeP2PKT(provider);

        /* Calculate Provider commission. */
        int providerCommission = (wiserValueOut * providerRate) / BASIS_POINTS;

        /* Validate Provider commission (dust) value. */
        // NOTE: Used to discourage denial-of-service (DoS) attack.
        providerCommission = max(providerCommission, DUST_VALUE);

        /* Set provider output index. */
        // NOTE: MUST be 2nd from last output.
        int providerOutputIdx = tx.outputs.length - 2;

        /* Verify Provider (payout) bytecode. */
        require(tx.outputs[providerOutputIdx].lockingBytecode == providerBytecode);

        /* Verify Provider (payout) amount. */
        require(tx.outputs[providerOutputIdx].value >= providerCommission);

        //----------------------------------------------------------------------
        // BEGIN TRADE CEILING & FLOOR PROTECTIONS
        //----------------------------------------------------------------------

        /* Validate (optional) coin ceiling. */
        // NOTE: Primarily used to guard the Foundation of a "new" asset
        //       during the beginning of its life-cycle.
        //       (see also: https://docs.nexa.exchange/create/foundation)
        if (coinCeiling != 0) {
            /* Calculate $TOKEN/$NEXA ratio. */
            // NOTE: $NEXA is the currency used for ALL fee calculations.
            int assetsRatio = wiserValueOutBP / wiserAmountOutBP;

            /* Validate $TOKEN/$NEXA ratio vs trade floor. */
            require(assetsRatio <= coinCeiling);
        }

        /* Validate (optional) coin floor. */
        // NOTE: Primarily used to guard the Foundation of a "new" asset
        //       during the beginning of its life-cycle.
        //       (see also: https://docs.nexa.exchange/create/foundation)
        if (coinFloor != 0) {
            /* Calculate $TOKEN/$NEXA ratio. */
            // NOTE: $NEXA is the currency used for ALL fee calculations.
            int assetsRatio = wiserValueOutBP / wiserAmountOutBP;

            /* Validate $TOKEN/$NEXA ratio vs trade floor. */
            require(assetsRatio >= coinFloor);
        }

        /* Validate (optional) token ceiling. */
        // NOTE: Primarily used to guard the Foundation of a "new" asset
        //       during the beginning of its life-cycle.
        //       (see also: https://docs.nexa.exchange/create/foundation)
        // if (tokenCeiling != 0) {
        //     /* Calculate $TOKEN/$NEXA ratio. */
        //     // NOTE: $NEXA is the currency used for ALL fee calculations.
        //     int assetsRatio = wiserAmountOutBP / wiserValueOutBP;
        //
        //     /* Validate $TOKEN/$NEXA ratio vs trade floor. */
        // }

        /* Validate (optional) token floor. */
        // NOTE: Primarily used to guard the Foundation of a "new" asset
        //       during the beginning of its life-cycle.
        //       (see also: https://docs.nexa.exchange/create/foundation)
        // if (tokenFloor != 0) {
        //     /* Calculate $TOKEN/$NEXA ratio. */
        //     // NOTE: $NEXA is the currency used for ALL fee calculations.
        //     int assetsRatio = wiserAmountOutBP / wiserValueOutBP;
        //
        //     /* Validate $TOKEN/$NEXA ratio vs trade floor. */
        //     require(assetsRatio >= tokenFloor);
        // }

        //----------------------------------------------------------------------
        // END TRADE CEILING & FLOOR PROTECTIONS
        //----------------------------------------------------------------------
    }

    /**
     * Manage (Pool)
     *
     * Liquidity providers can manage assets held in the pool contract, eg.
     *   1. Withdraw all funds.
     *   2. Re-balance the pool (aka adjust the price).
     *
     * NOTE: ONLY the pool's (owner) Provider can perform this action.
     */
    function manage(pubkey authorized, sig signature) {
        /* Calculate authorized (public key) hash. */
        // NOTE: Must match `PUSH AsData(PUSH pubkey)` specification found at
        //       https://spec.nexa.org/nexa/scriptTemplates.
        bytes20 authorizedHash = hash160(
            bytes(authorized.length) + authorized);

        /* Validate authorized provider. */
        require(authorizedHash == provider);

        /* Validate transaction signature. */
        require(checkSig(signature, authorized));
    }
}
