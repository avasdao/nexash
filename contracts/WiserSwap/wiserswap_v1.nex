pragma nexscript >= 0.2.0;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * Copyright (c) 2023 Ava's DAO
 * Released under the MIT License.
 *
 * WiserSwap
 *
 * A "wise" contract implemenation of a Constant Product Market Maker (CPMM)
 * for Nexa, using a micro-pools approach.
 *
 * Individual liquidity provider(s) may employ their own CPMM contract(s) for
 * managing their own micro-pool(s). This design leverages Nexa's UTXO model
 * and its 100K TPS throughput, allowing for unparalled scalability and
 * efficiency as compared to ANY modern-day DEX.
 *
 * GENERAL NOTES
 * --------------------
 * Based on the (CPMM) Cauldron contract by Dagur Valberg Johannsson
 * (source: https://www.cauldron.quest/_files/ugd/ae85be_b1dc04d2b6b94ab5a200e3d8cd197aa3.pdf)
 *
 * Constant Product Property
 * ----------------------------------------
 * WiserSwap adheres to the constant product formula:
 *   K = x * y
 * where K is the constant value, and x and y represent the quantities of
 * <Tokens> and <NEXA>, respectively.
 *
 * Aggregating Micro-Pools
 * ----------------------------------------
 * WiserSwap supports aggregation of micro-pools to increase liquidity for
 * trades. Multiple pools can be included in a single Transaction to increase
 * asset liquidity and swap efficiency.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * Version     : 01
 * Script Hash : 0x0000000000000000000000000000000000000000
 * Namespace   : WISER01
 *
 * owner       : (pubkey)  The Seller's FULL public key.
 * ownerFee    : (int)     An optional amount charged by the Owner. (measured in <basis points> (bp), eg. 5.25% = 525bp)
 * autoPayout  : (int)     An optional (fee) value (in satoshis) that will trigger an auto-payment to the Owner.
 * payout      : (bytes20) An optional Payout address (only if auto payout is enabled).
 * provider    : (bytes20) An optional 3rd-party (specified by the Seller) used to facilitate the transaction.
 * providerFee : (int)     An optional amount charged by the Provider. (measured in <basis points> (bp), eg. 5.25% = 525bp)
 *
 * For more information, please visit the following resources:
 *   - https://docs.nexa.exchange/wiserswap
 *   - https://avasdao.org
 *
 */
contract WiserSwap(
    pubkey owner,
    int ownerFee,
    int autoPayout,
    bytes20 payout,
    bytes20 provider,
    int providerFee,
    pubkey admin,
    int foundation,
) {
    /**
     * Swap (Pool Assets)
     *
     * Allows two (2) assets to be swapped with each other, while maintaining
     * the same (constant) product within the pool.
     */
    function swap(
        datasig adminSig,
        bytes adminMsg,
    ) {
        /* Set Wiser index. */
        int wiserIdx = this.activeInputIndex;

        /* Set Wiser (input) bytecode. */
        // NOTE: Used to compare inputs & outputs (excl `tokenAmount`).
        bytes wiserBytesIn = tx.inputs[wiserIdx].lockingBytecode;

        /* Set Wiser (output) bytecode. */
        // NOTE: Used to compare inputs & outputs (excl `tokenAmount`).
        bytes wiserBytesOut = tx.outputs[wiserIdx].lockingBytecode;

        /* Validate input & output bytecodes (excl `tokenAmount`). */
        require(wiserBytesOut == wiserBytesIn);

        /* Set Wiser (satoshis) input value. */
        int wiserValueIn = tx.inputs[wiserIdx].value;

        /* Set Wiser (token) input amount. */
        int wiserAmountIn = tx.inputs[wiserIdx].tokenAmount;

        /* Calculate Wiser (K) input constant. */
        int wiserConstantIn = wiserValueIn * wiserAmountIn;

        /* Set Wiser (satoshis) output value. */
        int wiserValueOut = tx.outputs[wiserIdx].value;

        /* Set Wiser (token) output amount. */
        int wiserAmountOut = tx.outputs[wiserIdx].tokenAmount;

        /* Calculate Wiser (K) output constant. */
        int wiserConstantOut = wiserValueOut * wiserAmountOut;

        /* Validate constant product (K) is maintained. */
        require(wiserConstantOut == wiserConstantIn);

        /* Initialize (transaction) total swap value. */
        int totalSwapValue = 0;

        /* Initialize (tail) index. */
        // NOTE: Use for calculating (change) outputs. */
        int tailIdx = 0;

        /* Validate inputs & outputs. */
        // NOTE: Test for (change) output, used in fee calculations.
        if (tx.outputs.length > tx.inputs.length) {
            /* Calculate total swap value. */
            // NOTE: Assume # of inputs is the (index) for (change) output.
            totalSwapValue = (tx.amountOut - tx.outputs[tx.inputs.length].value);

            /* Set (tail) index. */
            tailIdx = 1;
        } else {
            /* Set total swap value. */
            // NOTE: Used to calculate the provider fee.
            totalSwapValue = tx.amountOut;
        }

        /* Calculate (Provider) commission. */
        int ownerCommission = (totalSwapValue * ownerFee) / 10000;

        // FIXME
        require(ownerCommission == 0);

        /* Calculate public key hash. */
        bytes20 ownerPkh = hash160(owner);

        /* Create Provider bytecode. */
        // NOTE: Supports ONLY $NEXA assets.
        bytes23 ownerBytecode = new LockingBytecodeP2PKT(ownerPkh);

        /* Calculate (Provider) commission. */
        int providerCommission = (totalSwapValue * providerFee) / 10000;

        /* Validate auto-payout. */
        if (autoPayout >= ownerCommission) {
            /* Verify Provider bytecode. */
            // NOTE: Assume to be the LAST output.
            require(tx.outputs[tx.outputs.length - tailIdx].lockingBytecode == ownerBytecode);

            // TODO Handle Provider fee (w/ auto-payout).
            require(payout == 0x0);
            require(provider == 0x0);
        } else {
            /* Re-calculate total swap value. */
            // NOTE: Subtract owner commission. */

            // NOTE: Assumed to be the 2nd to last output.
            require(tx.outputs[tx.outputs.length - tailIdx - 1].lockingBytecode == ownerBytecode);
        }

        /* Set dust value. */
        int DUST_VALUE = 546;

        /* Validate auto-payout value. */
        require(autoPayout == 0 || autoPayout >= DUST_VALUE);

        /* Validate minimum Provider commission. */
        // NOTE: Used to discourage denial-of-service (DoS) attack.
        require(providerCommission >= DUST_VALUE);

        /* Validate minimum Owner commission. */
        // NOTE: Used to discourage denial-of-service (DoS) attack.
        require(ownerCommission >= DUST_VALUE);

        /* Validate (optional) admin key. */
        if (bytes(admin) != 0x0) {
            /* Calculate (foundation) ratio. */
            int ratio = wiserValueOut / wiserAmountOut;

            /* Validate swap w/ Admin (during training period). */
            require(checkDataSig(adminSig, adminMsg, admin));

            /* Validate admin (ratio) message. */
            require(ratio >= int(adminMsg.split(8)[0]));

            /* Validate admin (tx idem) message. */
            require(tx.idem == adminMsg.split(8)[1]);

            /* Validate foundation ratio. */
            require(foundation > ratio);
        }
    }

    /**
     * Manage (Pool)
     *
     * Liquidity providers can manage assets held in the pool contract, eg.
     *   1. Withdraw all funds
     *   2. Re-balance the pool (aka adjust the price).
     *
     * NOTE: ONLY the pool's Owner can perform this action.
     */
    function manage(sig signature) {
        /* Verify transaction is signed by the owner. */
        require(checkSig(signature, owner));
    }
}
